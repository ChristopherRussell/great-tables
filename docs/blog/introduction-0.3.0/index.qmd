---
title: "Great Tables `v0.3.0`: So Many More Options!"
html-table-processing: none
author: Rich Iannone
date: 2024-02-16
freeze: true
jupyter: python3
---

As our work on **Great Tables** continues, we want you to be able to produce increasingly sophisticated tables. The look of an HTML table really matters and we believe aesthetics can elevate the presentation of tabular data. In the `v0.3.0` release, we've implemented features that are concerned with modifying the visual aspects of a table. Let's get down to what's new in this version.

### Modifying the widths of columns

Before `v0.3.0`, you could not alter the widths of individual columns. This meant that to great extent your content decided the width of individual columns. Even though browsers do an adequate job in sizing the widths of table columns, it doesn't always result in a pleasing-to-look-at table. What if you want more space? Maybe you want consistently-sized columns? There's many reasons to want to have a choice in the matter and the new `cols_width()` method now makes this possible. Here's an example of a table where the column widths are defined with `cols_width()`, using a mix of pixel and percentage widths applied to select columns.

```{python}
from great_tables import GT, exibble

exibble_mini = exibble[["num", "char", "date", "datetime", "row"]].head(5)

(
    GT(exibble_mini)
    .cols_width(
        cases={
            "num": "150px",
            "char": "10%",
            "date": "30%"
        }
    )
)
```

In the previous example, the width settings govern the preferred sizes of the columns. But, depending on the nature of the content, the browser has license to make adjustments. An interesting thing happens if we set the width of all columns with pixel values: the table must use the specified widths as provided. In this next example we'll set widths for all columns, ensuring that the widths you specify are fully respected.

```{python}
(
    GT(exibble_mini)
    .cols_width(
        cases={
            "num": "30px",
            "char": "100px",
            "date": "100px",
            "datetime": "200px",
            "row": "50px"
        }
    )
)
```

### Setting options across the entire table with `tab_options()`

The new `tab_options()` method gives you the freedom to specify any of dozens of global style and layout options for the table. Want a font that's used across all cells? Use the `table_font_names` option. Do you need to make the text smaller, but only in the stub? Use `stub_font_size` for that. The number of options is perhaps overwhelming at first but we think you'll enjoy having them around nonetheless. It makes styling the table (and developing your own table themes) a relatively simple task.

Here's an example that creates a table with a few common components and then uses `tab_options()` to set up a collection of fonts for the table with the (also new) `system_fonts()` function:

```{python}
from great_tables import GT, exibble, md, system_fonts

gt_tbl = (
    GT(
        exibble[["num", "char", "currency", "row", "group"]],
        rowname_col="row",
        groupname_col="group",
    )
    .tab_header(
        title=md("Data listing from **exibble**"),
        subtitle=md("`exibble` is a **Great Tables** dataset."),
    )
    .fmt_number(columns="num")
    .fmt_currency(columns="currency")
    .tab_source_note(source_note="This is only a subset of the dataset.")
)

gt_tbl.tab_options(table_font_names=system_fonts("industrial"))
```

Note that `table_font_names=` accepts a list of fonts that operate as fallbacks for users across different systems (i.e., they may not have the font you have). And the `system_fonts()` helper function in **Great Tables** makes this easy by providing you with themed, local font stacks that are meant to work across different computing platforms.

Here's another example where we set the width of the table to span across the entire page (or containing element).

```{python}
gt_tbl.tab_options(table_width="100%")
```

One more where the background color of the table is set to `"lightcyan"`:

```{python}
gt_tbl.tab_options(table_background_color="lightcyan")
```

### Using the new `opt_*()` methods to do more complex tasks with table options

While `tab_options()` is a great method for setting global table options, sometimes you want to set a number of them at once for a combined effect. For that type of operation, we have the `opt_*()` series of methods. A common thing you might do is align the content in the table header, we can make that an easy thing with `opt_align_table_header()`:

```{python}
gt_tbl.opt_align_table_header(align="left")
```

With that, you don't have to hunt through the myriad options within `tab_options()` to find the two args you need to get the job done.

The `opt_all_caps()` method transforms the text within the column labels, the stub, and in all row groups so that we get an all-capitalized (yet somewhat sized down) look that better differentiates the labels from the data. It's rather easy to use, just do this:

```{python}
gt_tbl.opt_all_caps()
```

This sets nine options you'd otherwise set in `tab_options()` all at once, making life generally easier.

Here's one last example, this time using `opt_vertical_padding()`. You'd use that if you're dissatisfied with the level of top/bottom padding within cells of all locations (e.g., in the table body, in the column labels, etc.). You can either make a table taller or more 'compressed' with a single argument: `scale=`. Here's an example where the amount of vertical padding is reduced, resulting in a table taking up less vertical space.

```{python}
gt_tbl.opt_vertical_padding(scale=0.5)
```

### A new formatting method: `fmt_image()`

Wouldn't it be great to add graphics to your table? I mean, you can already do that with `fmt_markdown()` by creating a link to an image resource, but `fmt_image()` provides an easier way to add image files on disk into table body cells. This method allows for one or more images to be placed in the targeted cells. The cells need to contain some reference to an image file, either: (1) complete http/https or local paths to the files; (2) the file names, where a common path can be provided via the `path=` arg; or (3) a fragment of the file name, where the `file_pattern=` arg helps to compose the entire file name and `path=` provides the path information.

Here's an example using the `metro` dataset that's included within **Great Tables**.

```{python}
from great_tables.data import metro
from importlib_resources import files

img_paths = files("great_tables") / "data/metro_images"
metro_mini = metro[["name", "lines", "passengers"]].head(5)

(
    GT(metro_mini)
    .fmt_image(columns="lines", path=img_paths, file_pattern="metro_{}.svg")
    .fmt_integer(columns="passengers")
    .cols_label(
        name="Station",
        lines="Metro Lines",
        passengers="Passengers per Year (2021)"
    )
    .tab_options(table_width="700px")
)
```

The package has some graphics stored in the `data/metro_images` directory. They are SVGs are they look *very* nice in this table!
See the [fmt_image()](`great_tables.GT.fmt_image`) reference page for more information.

### Wrapping up

This `v0.3.0` release has some great new methods that add value to most any table-making endeavor. We also fixed a few bugs along the way so that you'll have a painless experience when building beautiful tables. As ever, we'll work toward more and more improvements to give you more creative possibilities!
